// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\SimulinkCFARHDLWorkflowExampleNew\Alpha_HDL.v
// Created: 2023-05-30 17:04:46
// 
// Generated by MATLAB 9.12 and HDL Coder 3.20
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Alpha_HDL
// Source Path: SimulinkCFARHDLWorkflowExampleNew/CFAR Implementation Model/Alpha HDL
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Alpha_HDL
          (clk,
           reset,
           enb,
           alpha);


  input   clk;
  input   reset;
  input   enb;
  output  signed [33:0] alpha;  // sfix34_En12


  wire [31:0] alpha1_out1;  // ufix32
  reg [31:0] Delay3_reg [0:1];  // ufix32 [2]
  wire [31:0] Delay3_reg_next [0:1];  // ufix32 [2]
  wire [31:0] Delay3_out1;  // ufix32
  wire [31:0] N1_out1;  // ufix32
  reg [31:0] Delay14_out1;  // ufix32
  wire pw2_sign_const;  // ufix1
  wire signed [8:0] pw2_shift_const;  // sfix9
  wire [31:0] Gain_out1;  // ufix32
  wire [31:0] PFA_out1;  // ufix32
  reg [31:0] Delay15_out1;  // ufix32
  wire [31:0] alpha1_N;  // ufix32
  wire [31:0] alpha1_N_1;  // ufix32
  reg [31:0] Delay1_out1;  // ufix32
  wire [31:0] log_PFA;  // ufix32
  wire [31:0] log_PFA_1;  // ufix32
  wire [31:0] Product_out1;  // ufix32
  wire [31:0] Pow10_out1;  // ufix32
  wire [31:0] Constant2_out1;  // ufix32
  reg [31:0] Delay7_out1;  // ufix32
  wire [31:0] Subtract_out1;  // ufix32
  reg [31:0] Delay9_out1;  // ufix32
  reg [31:0] Delay10_out1;  // ufix32
  reg [31:0] Delay11_out1;  // ufix32
  reg [31:0] Delay12_out1;  // ufix32
  wire [31:0] alpha_1;  // ufix32
  wire [31:0] alpha_2;  // ufix32
  wire signed [33:0] Data_Type_Conversion_out1;  // sfix34_En12


  assign alpha1_out1 = 32'hbf800000;



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_reg[0] <= 32'h3f800000;
        Delay3_reg[1] <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay3_reg[0] <= Delay3_reg_next[0];
          Delay3_reg[1] <= Delay3_reg_next[1];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[1];
  assign Delay3_reg_next[0] = alpha1_out1;
  assign Delay3_reg_next[1] = Delay3_reg[0];



  assign N1_out1 = 32'h42c80000;



  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_out1 <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay14_out1 <= N1_out1;
        end
      end
    end



  assign pw2_sign_const = 1'b0;



  assign pw2_shift_const = 9'sb000000001;



  nfp_gain_pow2_single u_nfp_gain_pow2_single (.nfp_in1(Delay14_out1),  // single
                                               .nfp_in2(pw2_sign_const),  // ufix1
                                               .nfp_in3(pw2_shift_const),  // sfix9
                                               .nfp_out(Gain_out1)  // single
                                               );

  assign PFA_out1 = 32'h3e2e147b;



  always @(posedge clk or posedge reset)
    begin : Delay15_process
      if (reset == 1'b1) begin
        Delay15_out1 <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay15_out1 <= PFA_out1;
        end
      end
    end



  nfp_div_single u_nfp_div_comp (.nfp_in1(Delay3_out1),  // single
                                 .nfp_in2(Gain_out1),  // single
                                 .nfp_out(alpha1_N)  // single
                                 );

  assign alpha1_N_1 = alpha1_N;

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Delay15_out1;
        end
      end
    end



  nfp_log10_single u_nfp_log10_comp (.nfp_in(Delay1_out1),  // single
                                     .nfp_out(log_PFA)  // single
                                     );

  assign log_PFA_1 = log_PFA;

  nfp_mul_single u_nfp_mul_comp (.nfp_in1(alpha1_N_1),  // single
                                 .nfp_in2(log_PFA_1),  // single
                                 .nfp_out(Product_out1)  // single
                                 );

  nfp_pow10_single u_nfp_pow10_comp (.nfp_in(Product_out1),  // single
                                     .nfp_out(Pow10_out1)  // single
                                     );

  assign Constant2_out1 = 32'h3f800000;



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= Constant2_out1;
        end
      end
    end



  nfp_sub_single u_nfp_sub_comp (.nfp_in1(Pow10_out1),  // single
                                 .nfp_in2(Delay7_out1),  // single
                                 .nfp_out(Subtract_out1)  // single
                                 );

  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_out1 <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay9_out1 <= Gain_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_out1 <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay10_out1 <= Delay9_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= Delay10_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 32'h3f800000;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= Delay11_out1;
        end
      end
    end



  nfp_mul_single u_nfp_mul_comp_1 (.nfp_in1(Subtract_out1),  // single
                                   .nfp_in2(Delay12_out1),  // single
                                   .nfp_out(alpha_1)  // single
                                   );

  assign alpha_2 = alpha_1;

  nfp_convert_single_to_sfix_34_En12 u_SimulinkCFARHDLWorkflowExampleNew_CFAR_Implementation_Model_Alpha_HDL_nfp_convert_single_to_sfix_34_En12 (.nfp_in(alpha_2),  // single
                                                                                                                                                 .nfp_out(Data_Type_Conversion_out1)  // sfix34_En12
                                                                                                                                                 );

  assign alpha = Data_Type_Conversion_out1;

endmodule  // Alpha_HDL

