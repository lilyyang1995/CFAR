// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\SimulinkCFARHDLWorkflowExampleNew\CFAR_Implementation_Model_tb.v
// Created: 2023-05-30 17:06:33
// 
// Generated by MATLAB 9.12 and HDL Coder 3.20
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// Detection                     ce_out        1
// Threshold                     ce_out        1
// ValidOut                      ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: CFAR_Implementation_Model_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module CFAR_Implementation_Model_tb;



  reg  clk;
  reg  reset;
  wire clk_enable;
  wire rawData_Valid;
  wire ValidOut_done;  // ufix1
  wire rdEnb;
  wire ValidOut_done_enb;  // ufix1
  reg [11:0] Detection_addr;  // ufix12
  wire ValidOut_lastAddr;  // ufix1
  wire resetn;
  reg  check3_done;  // ufix1
  wire Threshold_done;  // ufix1
  wire Threshold_done_enb;  // ufix1
  wire Threshold_lastAddr;  // ufix1
  reg  check2_done;  // ufix1
  wire Detection_done;  // ufix1
  wire Detection_done_enb;  // ufix1
  wire Detection_active;  // ufix1
  reg  holdData_Valid;
  reg  Valid_offset;
  wire Valid_1;
  reg [11:0] Quantize_out1_addr;  // ufix12
  wire [11:0] Quantize_out2_addr_delay_1;  // ufix12
  reg  tb_enb_delay;
  reg signed [31:0] fp_CUTidx;  // sfix32
  reg signed [15:0] rawData_CUTidx;  // int16
  reg signed [31:0] status_CUTidx;  // sfix32
  reg signed [15:0] holdData_CUTidx;  // int16
  reg signed [15:0] CUTidx_offset;  // int16
  wire signed [15:0] CUTidx;  // int16
  wire Quantize_out1_active;  // ufix1
  wire Quantize_out1_enb;  // ufix1
  wire [11:0] Quantize_out1_addr_delay_1;  // ufix12
  reg signed [31:0] fp_Stream_Input;  // sfix32
  reg signed [33:0] rawData_Stream_Input;  // sfix34_En12
  reg signed [31:0] status_Stream_Input;  // sfix32
  reg signed [33:0] holdData_Stream_Input;  // sfix34_En12
  reg signed [33:0] Stream_Input_offset;  // sfix34_En12
  wire signed [33:0] Stream_Input;  // sfix34_En12
  wire snkDone;
  wire snkDonen;
  wire tb_enb;
  wire ce_out;
  wire Detection;
  wire signed [11:0] Threshold;  // sfix12_En8
  wire ValidOut;
  wire Detection_enb;  // ufix1
  wire Detection_lastAddr;  // ufix1
  reg  check1_done;  // ufix1
  wire [11:0] Detection_addr_delay_1;  // ufix12
  reg signed [31:0] fp_Detection_expected;  // sfix32
  reg  Detection_expected;
  reg signed [31:0] status_Detection_expected;  // sfix32
  wire Detection_ref;
  reg  Detection_testFailure;  // ufix1
  wire [11:0] Threshold_addr_delay_1;  // ufix12
  reg signed [31:0] fp_Threshold_expected;  // sfix32
  reg signed [11:0] Threshold_expected;  // sfix12_En8
  reg signed [31:0] status_Threshold_expected;  // sfix32
  wire signed [11:0] Threshold_ref;  // sfix12_En8
  reg  Threshold_testFailure;  // ufix1
  wire [11:0] ValidOut_addr_delay_1;  // ufix12
  reg signed [31:0] fp_ValidOut_expected;  // sfix32
  reg  ValidOut_expected;
  reg signed [31:0] status_ValidOut_expected;  // sfix32
  wire ValidOut_ref;
  reg  ValidOut_testFailure;  // ufix1
  wire testFailure;  // ufix1

  function real absReal(input real num);
  begin
    if (num < 0)
      absReal = -num;
    else
      absReal = num;
  end
  endfunction

  function real floatHalfToReal;
  input [15:0] x;
  reg [63:0] conv;

  begin
    conv[63] = x[15]; // sign 
    if (x[14:10] == 5'b0) // exp 
      conv[62:52] = 11'b0; 
    else
      conv[62:52] = 1023 + (x[14:10] - 15);
    conv[51:42] = x[9:0]; // mantissa 
    conv[41:0] = 42'b0;
    if (((x[14:10] == 5'h1F) && (x[9:0] != 10'h0))) // check for NaN 
    begin
      conv[63] = 1'b0;
      conv[62:52] = 11'h7FF;
      conv[51:0] = 52'h0;
    end
    floatHalfToReal = $bitstoreal(conv);
  end
  endfunction

  function real floatSingleToReal;
  input [31:0] x;
  reg [63:0] conv;

  begin
    conv[63] = x[31]; // sign 
    if (x[30:23] == 8'b0) // exp 
      conv[62:52] = 11'b0; 
    else
      conv[62:52] = 1023 + (x[30:23] - 127);
    conv[51:29] = x[22:0]; // mantissa 
    conv[28:0] = 29'b0;
    if (((x[30:23] == 8'hFF) && (x[22:0] != 23'h0))) // check for NaN 
    begin
      conv[63] = 1'b0;
      conv[62:52] = 11'h7FF;
      conv[51:0] = 52'h0;
    end
    floatSingleToReal = $bitstoreal(conv);
  end
  endfunction

  function real floatDoubleToReal;
  input [63:0] x;
  reg [63:0] conv;

  begin
    conv[63:0] = x[63:0]; 
    if (((x[62:52] == 11'h7FF) && (x[51:0] != 52'h0))) // check for NaN 
    begin
      conv[63] = 1'b0;
      conv[62:52] = 11'h7FF;
      conv[51:0] = 52'h0;
    end
    floatDoubleToReal = $bitstoreal(conv);
  end
  endfunction

  function isFloatEpsEqual(input real a, input real b, input real eps);
  real absdiff;

  begin
    absdiff = absReal(a - b);
    if (absdiff < eps) // absolute error check 
      isFloatEpsEqual = 1;
    else if (a == b) // check infinities 
      isFloatEpsEqual = 1; 
    else if (a*b == 0.0) // either is zero 
      isFloatEpsEqual = (absdiff < eps);
    else if (absReal(a) < absReal(b)) // relative error check
      isFloatEpsEqual = absdiff/absReal(b) < eps;
    else
      isFloatEpsEqual = absdiff/absReal(a) < eps;
  end
  endfunction
  function isFloatHalfEpsEqual;
  input [15:0] x;
  input [15:0] y;
  input real eps;
  real a, b;
  real absdiff;

  begin
    a = floatHalfToReal(x);
    b = floatHalfToReal(y);
    isFloatHalfEpsEqual = isFloatEpsEqual(a, b, eps);
  end
  endfunction
  function isFloatSingleEpsEqual;
  input [31:0] x;
  input [31:0] y;
  input real eps;
  real a, b;
  real absdiff;

  begin
    a = floatSingleToReal(x);
    b = floatSingleToReal(y);
    isFloatSingleEpsEqual = isFloatEpsEqual(a, b, eps);
  end
  endfunction
  function isFloatDoubleEpsEqual;
  input [63:0] x;
  input [63:0] y;
  input real eps;
  real a, b;
  real absdiff;

  begin
    a = floatDoubleToReal(x);
    b = floatDoubleToReal(y);
    isFloatDoubleEpsEqual = isFloatEpsEqual(a, b, eps);
  end
  endfunction

  // Data source for Valid
  assign rawData_Valid = 1'b1;



  assign ValidOut_done_enb = ValidOut_done & rdEnb;



  assign ValidOut_lastAddr = Detection_addr >= 12'b101010001100;



  assign ValidOut_done = ValidOut_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_3
      if (reset) begin
        check3_done <= 0;
      end
      else begin
        if (ValidOut_done_enb) begin
          check3_done <= ValidOut_done;
        end
      end
    end

  assign Threshold_done_enb = Threshold_done & rdEnb;



  assign Threshold_lastAddr = Detection_addr >= 12'b101010001100;



  assign Threshold_done = Threshold_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_2
      if (reset) begin
        check2_done <= 0;
      end
      else begin
        if (Threshold_done_enb) begin
          check2_done <= Threshold_done;
        end
      end
    end

  assign Detection_done_enb = Detection_done & rdEnb;



  assign Detection_active = Detection_addr != 12'b101010001100;



  // holdData reg for Data_Type_Conversion1_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Data_Type_Conversion1_out1
      if (reset) begin
        holdData_Valid <= 1'bx;
      end
      else begin
        holdData_Valid <= rawData_Valid;
      end
    end

  always @(rawData_Valid or rdEnb)
    begin : stimuli_Data_Type_Conversion1_out1_1
      if (rdEnb == 1'b0) begin
        Valid_offset <= holdData_Valid;
      end
      else begin
        Valid_offset <= rawData_Valid;
      end
    end

  assign #2 Valid_1 = Valid_offset;

  assign #1 Quantize_out2_addr_delay_1 = Quantize_out1_addr;

  // Data source for CUTidx
  initial
    begin : CUTidx_fileread
      fp_CUTidx = $fopen("/data/icdesign/ams/Adt_high_speed_IO/user/lilyyang/CFAR_hdl_0530/CUTidx.dat", "r");
      status_CUTidx = $rewind(fp_CUTidx);
    end

  always @(Quantize_out2_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_CUTidx <= 16'bx;
      end
      else if (rdEnb == 1) begin
        status_CUTidx = $fscanf(fp_CUTidx, "%h", rawData_CUTidx);
      end
    end

  // holdData reg for Quantize_out2
  always @(posedge clk or posedge reset)
    begin : stimuli_Quantize_out2
      if (reset) begin
        holdData_CUTidx <= 16'bx;
      end
      else begin
        holdData_CUTidx <= rawData_CUTidx;
      end
    end

  always @(rawData_CUTidx or rdEnb)
    begin : stimuli_Quantize_out2_1
      if (rdEnb == 1'b0) begin
        CUTidx_offset <= holdData_CUTidx;
      end
      else begin
        CUTidx_offset <= rawData_CUTidx;
      end
    end

  assign #2 CUTidx = CUTidx_offset;

  assign Quantize_out1_active = Quantize_out1_addr != 12'b101010001100;



  assign Quantize_out1_enb = Quantize_out1_active & (rdEnb & tb_enb_delay);



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2700
  always @(posedge clk or posedge reset)
    begin : Quantize_process
      if (reset == 1'b1) begin
        Quantize_out1_addr <= 12'b000000000000;
      end
      else begin
        if (Quantize_out1_enb) begin
          if (Quantize_out1_addr >= 12'b101010001100) begin
            Quantize_out1_addr <= 12'b000000000000;
          end
          else begin
            Quantize_out1_addr <= Quantize_out1_addr + 12'b000000000001;
          end
        end
      end
    end



  assign #1 Quantize_out1_addr_delay_1 = Quantize_out1_addr;

  // Data source for Stream_Input
  initial
    begin : Stream_Input_fileread
      fp_Stream_Input = $fopen("/data/icdesign/ams/Adt_high_speed_IO/user/lilyyang/CFAR_hdl_0530/Stream_Input.dat", "r");
      status_Stream_Input = $rewind(fp_Stream_Input);
    end

  always @(Quantize_out1_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_Stream_Input <= 34'bx;
      end
      else if (rdEnb == 1) begin
        status_Stream_Input = $fscanf(fp_Stream_Input, "%h", rawData_Stream_Input);
      end
    end

  // holdData reg for Quantize_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Quantize_out1
      if (reset) begin
        holdData_Stream_Input <= 34'bx;
      end
      else begin
        holdData_Stream_Input <= rawData_Stream_Input;
      end
    end

  always @(rawData_Stream_Input or rdEnb)
    begin : stimuli_Quantize_out1_1
      if (rdEnb == 1'b0) begin
        Stream_Input_offset <= holdData_Stream_Input;
      end
      else begin
        Stream_Input_offset <= rawData_Stream_Input;
      end
    end

  assign #2 Stream_Input = Stream_Input_offset;

  assign snkDonen =  ~ snkDone;



  assign resetn =  ~ reset;



  assign tb_enb = resetn & snkDonen;



  // Delay inside enable generation: register depth 1
  always @(posedge clk or posedge reset)
    begin : u_enable_delay
      if (reset) begin
        tb_enb_delay <= 0;
      end
      else begin
        tb_enb_delay <= tb_enb;
      end
    end

  assign rdEnb = (snkDone == 1'b0 ? tb_enb_delay :
              1'b0);



  assign #2 clk_enable = rdEnb;

  initial
    begin : reset_gen
      reset <= 1'b1;
      # (20);
      @ (posedge clk)
      # (2);
      reset <= 1'b0;
    end

  always 
    begin : clk_gen
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (5);
        clk <= 1'b0;
        # (5);
        $stop;
      end
    end

  CFAR_Implementation_Model u_CFAR_Implementation_Model (.clk(clk),
                                                         .reset(reset),
                                                         .clk_enable(clk_enable),
                                                         .Stream_Input(Stream_Input),  // sfix34_En12
                                                         .CUTidx(CUTidx),  // int16
                                                         .Valid(Valid_1),
                                                         .ce_out(ce_out),
                                                         .Detection(Detection),
                                                         .Threshold(Threshold),  // sfix12_En8
                                                         .ValidOut(ValidOut)
                                                         );

  assign Detection_enb = ce_out & Detection_active;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2700
  always @(posedge clk or posedge reset)
    begin : c_2_process
      if (reset == 1'b1) begin
        Detection_addr <= 12'b000000000000;
      end
      else begin
        if (Detection_enb) begin
          if (Detection_addr >= 12'b101010001100) begin
            Detection_addr <= 12'b000000000000;
          end
          else begin
            Detection_addr <= Detection_addr + 12'b000000000001;
          end
        end
      end
    end



  assign Detection_lastAddr = Detection_addr >= 12'b101010001100;



  assign Detection_done = Detection_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_1
      if (reset) begin
        check1_done <= 0;
      end
      else begin
        if (Detection_done_enb) begin
          check1_done <= Detection_done;
        end
      end
    end

  assign snkDone = check3_done & (check1_done & check2_done);



  assign #1 Detection_addr_delay_1 = Detection_addr;

  // Data source for Detection_expected
  initial
    begin : Detection_expected_fileread
      fp_Detection_expected = $fopen("/data/icdesign/ams/Adt_high_speed_IO/user/lilyyang/CFAR_hdl_0530/Detection_expected.dat", "r");
      status_Detection_expected = $rewind(fp_Detection_expected);
    end

  always @(Detection_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        Detection_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_Detection_expected = $fscanf(fp_Detection_expected, "%h", Detection_expected);
      end
    end

  assign Detection_ref = Detection_expected;

  always @(posedge clk or posedge reset)
    begin : Detection_checker
      if (reset == 1'b1) begin
        Detection_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && Detection !== Detection_ref) begin
          Detection_testFailure <= 1'b1;
          $display("ERROR in Detection at time %t : Expected '%h' Actual '%h'", $time, Detection_ref, Detection);
        end
      end
    end

  assign #1 Threshold_addr_delay_1 = Detection_addr;

  // Data source for Threshold_expected
  initial
    begin : Threshold_expected_fileread
      fp_Threshold_expected = $fopen("/data/icdesign/ams/Adt_high_speed_IO/user/lilyyang/CFAR_hdl_0530/Threshold_expected.dat", "r");
      status_Threshold_expected = $rewind(fp_Threshold_expected);
    end

  always @(Threshold_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        Threshold_expected <= 12'bx;
      end
      else if (ce_out == 1) begin
        status_Threshold_expected = $fscanf(fp_Threshold_expected, "%h", Threshold_expected);
      end
    end

  assign Threshold_ref = Threshold_expected;

  always @(posedge clk or posedge reset)
    begin : Threshold_checker
      if (reset == 1'b1) begin
        Threshold_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && Threshold !== Threshold_ref) begin
          Threshold_testFailure <= 1'b1;
          $display("ERROR in Threshold at time %t : Expected '%h' Actual '%h'", $time, Threshold_ref, Threshold);
        end
      end
    end

  assign #1 ValidOut_addr_delay_1 = Detection_addr;

  // Data source for ValidOut_expected
  initial
    begin : ValidOut_expected_fileread
      fp_ValidOut_expected = $fopen("/data/icdesign/ams/Adt_high_speed_IO/user/lilyyang/CFAR_hdl_0530/ValidOut_expected.dat", "r");
      status_ValidOut_expected = $rewind(fp_ValidOut_expected);
    end

  always @(ValidOut_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ValidOut_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ValidOut_expected = $fscanf(fp_ValidOut_expected, "%h", ValidOut_expected);
      end
    end

  assign ValidOut_ref = ValidOut_expected;

  always @(posedge clk or posedge reset)
    begin : ValidOut_checker
      if (reset == 1'b1) begin
        ValidOut_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && ValidOut !== ValidOut_ref) begin
          ValidOut_testFailure <= 1'b1;
          $display("ERROR in ValidOut at time %t : Expected '%h' Actual '%h'", $time, ValidOut_ref, ValidOut);
        end
      end
    end

  assign testFailure = ValidOut_testFailure | (Detection_testFailure | Threshold_testFailure);



  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // CFAR_Implementation_Model_tb

