// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\SimulinkCFARHDLWorkflowExampleNew\Training_HDL.v
// Created: 2023-05-30 17:04:46
// 
// Generated by MATLAB 9.12 and HDL Coder 3.20
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Training_HDL
// Source Path: SimulinkCFARHDLWorkflowExampleNew/CFAR Implementation Model/CFAR Core/Training HDL
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Training_HDL
          (clk,
           reset,
           enb,
           SQR_LAW,
           CUTIdx_in,
           Noise_Power);


  input   clk;
  input   reset;
  input   enb;
  input   signed [33:0] SQR_LAW;  // sfix34_En12
  input   signed [15:0] CUTIdx_in;  // int16
  output  signed [33:0] Noise_Power;  // sfix34_En12


  wire signed [33:0] Compensatory_Lead_Cells_HDL_out1;  // sfix34_En12
  reg signed [33:0] Delay8_out1;  // sfix34_En12
  wire signed [33:0] Lead_Cells_HDL_out1;  // sfix34_En12
  reg signed [33:0] Delay6_out1;  // sfix34_En12
  wire signed [34:0] Total_Lead_add_cast;  // sfix35_En12
  wire signed [34:0] Total_Lead_add_cast_1;  // sfix35_En12
  wire signed [34:0] Total_Lead_add_temp;  // sfix35_En12
  wire signed [33:0] Total_Lead_out1;  // sfix34_En12
  reg signed [33:0] Delay2_reg [0:1];  // sfix34 [2]
  wire signed [33:0] Delay2_reg_next [0:1];  // sfix34_En12 [2]
  wire signed [33:0] Delay2_out1;  // sfix34_En12
  wire signed [33:0] Lag_Delay;  // sfix34_En12
  wire signed [33:0] Lag_Cells_HDL_out1;  // sfix34_En12
  reg signed [33:0] Delay9_out1;  // sfix34_En12
  wire signed [33:0] Compensatory_Lag_Cells_HDL_out1;  // sfix34_En12
  reg signed [33:0] Delay11_out1;  // sfix34_En12
  wire signed [34:0] Total_Lag_add_cast;  // sfix35_En12
  wire signed [34:0] Total_Lag_add_cast_1;  // sfix35_En12
  wire signed [34:0] Total_Lag_add_temp;  // sfix35_En12
  wire signed [33:0] Total_Lag_out1;  // sfix34_En12
  reg signed [33:0] Delay3_reg [0:1];  // sfix34 [2]
  wire signed [33:0] Delay3_reg_next [0:1];  // sfix34_En12 [2]
  wire signed [33:0] Delay3_out1;  // sfix34_En12
  wire signed [34:0] Add5_add_cast;  // sfix35_En12
  wire signed [34:0] Add5_add_cast_1;  // sfix35_En12
  wire signed [34:0] Add5_add_temp;  // sfix35_En12
  wire signed [33:0] Add5_out1;  // sfix34_En12
  reg signed [33:0] Delay4_out1;  // sfix34_En12
  wire signed [34:0] Delay4_out1_dtc;  // sfix35_En12
  wire signed [15:0] Constant2_out1;  // int16
  reg signed [15:0] Delay_out1;  // int16
  wire signed [31:0] Gain_cast;  // sfix32_En13
  wire signed [15:0] Gain_out1;  // int16
  reg signed [15:0] Delay1_out1;  // int16
  reg signed [33:0] Divide_out1;  // sfix34_En12
  reg signed [33:0] Delay5_out1;  // sfix34_En12
  reg signed [34:0] Divide_varargout_1;  // sfix35_En12
  reg signed [35:0] Divide_div_temp;  // sfix36_En12
  reg signed [35:0] Divide_cast;  // sfix36_En12

  // Lag Training HDL
  // 
  // Lead Training HDL
  // 
  // CA Noise Power HDL


  Compensatory_Lead_Cells_HDL u_Compensatory_Lead_Cells_HDL (.clk(clk),
                                                             .reset(reset),
                                                             .enb(enb),
                                                             .CUTidx(CUTIdx_in),  // int16
                                                             .SQR_LAW(SQR_LAW),  // sfix34_En12
                                                             .Compensatory_Lead_Sum(Compensatory_Lead_Cells_HDL_out1)  // sfix34_En12
                                                             );

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Delay8_out1 <= Compensatory_Lead_Cells_HDL_out1;
        end
      end
    end



  Lead_Cells_HDL u_Lead_Cells_HDL (.clk(clk),
                                   .reset(reset),
                                   .enb(enb),
                                   .SQR_LAW(SQR_LAW),  // sfix34_En12
                                   .Lead_Sum(Lead_Cells_HDL_out1)  // sfix34_En12
                                   );

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Lead_Cells_HDL_out1;
        end
      end
    end



  assign Total_Lead_add_cast = {Delay8_out1[33], Delay8_out1};
  assign Total_Lead_add_cast_1 = {Delay6_out1[33], Delay6_out1};
  assign Total_Lead_add_temp = Total_Lead_add_cast + Total_Lead_add_cast_1;
  assign Total_Lead_out1 = ((Total_Lead_add_temp[34] == 1'b0) && (Total_Lead_add_temp[33] != 1'b0) ? 34'sh1FFFFFFFF :
              ((Total_Lead_add_temp[34] == 1'b1) && (Total_Lead_add_temp[33] != 1'b1) ? 34'sh200000000 :
              $signed(Total_Lead_add_temp[33:0])));



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_reg[0] <= 34'sh000000000;
        Delay2_reg[1] <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Delay2_reg[0] <= Delay2_reg_next[0];
          Delay2_reg[1] <= Delay2_reg_next[1];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[1];
  assign Delay2_reg_next[0] = Total_Lead_out1;
  assign Delay2_reg_next[1] = Delay2_reg[0];



  Lag_Cells_Delay u_Lag_Cells_Delay (.clk(clk),
                                     .reset(reset),
                                     .enb(enb),
                                     .SQR_LAW(SQR_LAW),  // sfix34_En12
                                     .Lag_Delay(Lag_Delay)  // sfix34_En12
                                     );

  Lag_Cells_HDL u_Lag_Cells_HDL (.clk(clk),
                                 .reset(reset),
                                 .enb(enb),
                                 .Lag_Delay(Lag_Delay),  // sfix34_En12
                                 .Lag_Sum(Lag_Cells_HDL_out1)  // sfix34_En12
                                 );

  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_out1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Delay9_out1 <= Lag_Cells_HDL_out1;
        end
      end
    end



  Compensatory_Lag_Cells_HDL u_Compensatory_Lag_Cells_HDL (.clk(clk),
                                                           .reset(reset),
                                                           .enb(enb),
                                                           .CUTidx(CUTIdx_in),  // int16
                                                           .Lag_Delay(Lag_Delay),  // sfix34_En12
                                                           .Compensatory_Lag_Sum(Compensatory_Lag_Cells_HDL_out1)  // sfix34_En12
                                                           );

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= Compensatory_Lag_Cells_HDL_out1;
        end
      end
    end



  assign Total_Lag_add_cast = {Delay9_out1[33], Delay9_out1};
  assign Total_Lag_add_cast_1 = {Delay11_out1[33], Delay11_out1};
  assign Total_Lag_add_temp = Total_Lag_add_cast + Total_Lag_add_cast_1;
  assign Total_Lag_out1 = ((Total_Lag_add_temp[34] == 1'b0) && (Total_Lag_add_temp[33] != 1'b0) ? 34'sh1FFFFFFFF :
              ((Total_Lag_add_temp[34] == 1'b1) && (Total_Lag_add_temp[33] != 1'b1) ? 34'sh200000000 :
              $signed(Total_Lag_add_temp[33:0])));



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_reg[0] <= 34'sh000000000;
        Delay3_reg[1] <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Delay3_reg[0] <= Delay3_reg_next[0];
          Delay3_reg[1] <= Delay3_reg_next[1];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[1];
  assign Delay3_reg_next[0] = Total_Lag_out1;
  assign Delay3_reg_next[1] = Delay3_reg[0];



  assign Add5_add_cast = {Delay2_out1[33], Delay2_out1};
  assign Add5_add_cast_1 = {Delay3_out1[33], Delay3_out1};
  assign Add5_add_temp = Add5_add_cast + Add5_add_cast_1;
  assign Add5_out1 = ((Add5_add_temp[34] == 1'b0) && (Add5_add_temp[33] != 1'b0) ? 34'sh1FFFFFFFF :
              ((Add5_add_temp[34] == 1'b1) && (Add5_add_temp[33] != 1'b1) ? 34'sh200000000 :
              $signed(Add5_add_temp[33:0])));



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= Add5_out1;
        end
      end
    end



  assign Delay4_out1_dtc = {Delay4_out1[33], Delay4_out1};



  assign Constant2_out1 = 16'sb0000000001100100;



  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 16'sb0000000000000001;
      end
      else begin
        if (enb) begin
          Delay_out1 <= Constant2_out1;
        end
      end
    end



  assign Gain_cast = {{2{Delay_out1[15]}}, {Delay_out1, 14'b00000000000000}};
  assign Gain_out1 = Gain_cast[28:13];



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 16'sb0000000000000001;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Gain_out1;
        end
      end
    end



  always @(Delay1_out1, Delay4_out1_dtc) begin
    Divide_div_temp = 36'sh000000000;
    Divide_cast = 36'sh000000000;
    if (Delay1_out1 == 16'sb0000000000000000) begin
      if (Delay4_out1_dtc < 35'sh000000000) begin
        Divide_varargout_1 = 35'sh400000000;
      end
      else begin
        Divide_varargout_1 = 35'sh3FFFFFFFF;
      end
    end
    else begin
      Divide_cast = {Delay4_out1_dtc[34], Delay4_out1_dtc};
      Divide_div_temp = Divide_cast / Delay1_out1;
      if ((Divide_div_temp[35] == 1'b0) && (Divide_div_temp[34] != 1'b0)) begin
        Divide_varargout_1 = 35'sh3FFFFFFFF;
      end
      else if ((Divide_div_temp[35] == 1'b1) && (Divide_div_temp[34] != 1'b1)) begin
        Divide_varargout_1 = 35'sh400000000;
      end
      else begin
        Divide_varargout_1 = Divide_div_temp[34:0];
      end
    end
    if ((Divide_varargout_1[34] == 1'b0) && (Divide_varargout_1[33] != 1'b0)) begin
      Divide_out1 = 34'sh1FFFFFFFF;
    end
    else if ((Divide_varargout_1[34] == 1'b1) && (Divide_varargout_1[33] != 1'b1)) begin
      Divide_out1 = 34'sh200000000;
    end
    else begin
      Divide_out1 = Divide_varargout_1[33:0];
    end
  end



  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= Divide_out1;
        end
      end
    end



  assign Noise_Power = Delay5_out1;

endmodule  // Training_HDL

